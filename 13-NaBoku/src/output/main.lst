mads 2.1.1
  1133 					opt l+
    98 = 0000				?EXTDETECT = 0
    99 = 0000				?VBXDETECT = 0
   100
   101 2075				RCASM 'res/gr_dl.asm' DL_2 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCASM [Source: resource.asm]
     2 2075				org RESORIGIN
     4 = 001A			len = .sizeof(_DL_2)
     6 				mcpy	ift main.DL_2+len >= $bc20
    11 2075 20 41 20			jsr sys.off
    13 2078 A9 96 85 88 A9 20 +  MWA #DATA EDX
    13 2080 A9 00 85 8C A9 11 +  MWA #MAIN.DL_2 ECX
    13 2088 A9 1A 85 84 A9 00 +  MWA #LEN EAX
    13 2090 20 00 20		 JSR RESOURCE.MEMCPY
    15 2093 4C 65 20			jmp sys.on
    16 2096			data
Source: const.inc
     1 = 1000			PM_ADR              = $1000;                      // players & missiles memory (2K) start address
     2 = 1300			M0_ADR              = PM_ADR + $300;              // missile 0 start memory address
     3 = 1400			P0_ADR              = PM_ADR + $400;              // player 0 start memory address
     4 = 1500			P1_ADR              = PM_ADR + $500;              // player 1 start memory address
     5 = 1000			GFX_SHIP_ADR        = $1000;                      // ship gfx memory start address, ship size = 20 bytes, 16 bytes for gfx and 4 bytes fo top/bottom empty rows
     6 = 000A			GFX_SHIP_SEG        = 10;                         // ship gfx 10 byte segment, 10B for P0 & 10B for P1
     8 = 0E0E			SHIP_COL            = $0e0e;
     9 = 0030			SHIP_LEFT_LIMIT     = 48;
    10 = 00C0			SHIP_RIGHT_LIMIT    = SHIP_LEFT_LIMIT + (16 * 9);
    11 = 0020			SHIP_TOP_LIMIT      = 32;
    12 = 00A0			SHIP_BOTTOM_LIMIT   = 10 * 16;
    14 = 0008			JOY_LEFT            = %1000;
    15 = 0004			JOY_RIGHT           = %0100;
    16 = 0002			JOY_UP              = %0010;
    17 = 0001			JOY_DOWN            = %0001;
    19 = 1100			DL_2                = $1100;                      // display list memory start address for ANTIC mode 2
    20 = E000			GAME_LMS            = $e000;                      // Load Memory Scan address
     3 1100			dl2
     4 1100 F0 70 F0		    .byte $f0,$70,$f0
     5 1103 42 00 E0		    .byte $42,a(GAME_LMS)
     6 1106 02 02 02 02 02 02 + :17 .byte 2
     7 1117 41 00 11		    .byte $41,a(dl2)
    23 					.print '$R RCASM   ',main.DL_2,'..',main.DL_2+len-1," 'res/gr_dl.asm'"
    23 				$R RCASM   $1100..$1119 'res/gr_dl.asm'
    25 02E2-02E3> 75 20			ini mcpy
Source: main.a65
   102 20B0				RCDATA 'res/gfx_ship.bin' GFX_SHIP_ADR 0 0 0 0 0 0 0 0
Macro: RESOURCE.RCDATA [Source: resource.asm]
     2 = 0014			len = .filesize('res/gfx_ship.bin')
    28 20B0				org main.GFX_SHIP_ADR
    30 1000-1013> 00 70 7B 1E + 	ins 'res/gfx_ship.bin'
    32 					.print '$R RCDATA  ',main.GFX_SHIP_ADR,'..',*-1," 'res/gfx_ship.bin'"
    32 				$R RCDATA  $1000..$1013 'res/gfx_ship.bin'
Source: main.a65
   103 				.endl
   104
   105 				; ------------------------------------------------------------
   106
   107 1014				org CODEORIGIN
   108
   109 2000				STATICDATA
Macro: STATICDATA [Source: main.a65]
Source: main.a65
   110
   111 				; ------------------------------------------------------------
   112
   113 2000			RTLIB
   114 2000				icl 'rtl6502_a8.asm'
Source: rtl6502_a8.asm
   166 					opt l+
   115
   116 				.print 'ZPAGE: ',fxptr,'..',zpend-1
   116 				ZPAGE: $0080..$00D7
   117
   118 				.print 'RTLIB: ',RTLIB,'..',*-1
   118 				RTLIB: $2000..$20CE
   119
   120 				; ------------------------------------------------------------
   121
   122 20CF			START
   123 20CF BA				tsx
   124 20D0 8E EB 23			stx MAIN.@halt+1
   125
   126 					.ifdef fmulinit
   127 					fmulinit
   128 					eif
   129
   130 = 000D			VLEN	= VARDATASIZE-VARINITSIZE
   131 = 240A			VADR	= DATAORIGIN+VARINITSIZE
   132
   133 					ift VADR > $BFFF
   134 					ert 'Invalid memory address range ',VADR
   135 					eli (VLEN>0) && (VLEN<=256)
   136 20D3 A2 F3			ldx #256-VLEN
   137 20D5 A9 00			lda #$00
   138 20D7 9D 17 23 E8 D0 FA		sta:rne VADR+VLEN-256,x+
   139 					eli VLEN>0
   140 					@fill #VADR #VLEN #$00
   141 					eif
   142
   143 20DD A9 17 85 82 A9 24 + 	mwa #PROGRAMSTACK psptr
   144
   145 					.ifdef MAIN.@DEFINES.ROMOFF
   146 					icl 'atari\romoff.asm'
   147 					.endif
   148
   149 20E5 A2 0F			ldx #$0F					; DOS II+/D ParamStr
   150 20E7 BD 40 03 9D F0 23 + 	mva:rpl $340,x MAIN.IOCB@COPY,x-
   151
   152 20F0 E8				inx						; X = 0
   153 20F1 86 90			stx bp						; BP = 0
   154
   155 20F3 8E 08 D2			stx audctl					; reset POKEY
   156 20F6 A9 03			lda #3
   157 20F8 8D 0F D2			sta skctl
   158
   159 20FB CA				dex						; X = 255
   160
   161 20FC				UNITINITIALIZATION
Macro: UNITINITIALIZATION [Source: main.a65]
    11 20FC 20 A6 21			jsr MAIN.SYS.@UnitInit
    15 20FF 20 B2 21			jsr MAIN.GR.@UnitInit
    19 2102 20 EE 22			jsr MAIN.SPRITES.@UnitInit
   162
   163 2105			.local	MAIN						; PROCEDURE
   164
   165 2105 4C E4 23			jmp l_0007
   166
   167 				; ------------------------------------------------------------
   168
   169 2108			.local	SYSTEM						; UNIT
   170
   171 2108			.local	FILLBYTE_0042					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   172
   173 				; ------------------------------------------------------------
   174
   175 				; Generate Assignment for BYTE / CHAR / SHORTINT / BOOLEAN
   176 				; as Pointer
   177 2108 B5 98			lda :STACKORIGIN,x
   178 210A 85 84			sta VALUE
   179 210C CA				dex
   180
   181 				; ------------------------------------------------------------
   182
   183 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   184 				; as Pointer
   185 210D B5 98			lda :STACKORIGIN,x
   186 210F 85 8C			sta COUNT
   187 2111 B5 A8			lda :STACKORIGIN+STACKWIDTH,x
   188 2113 85 8D			sta COUNT+1
   189 2115 CA				dex
   190
   191 				; ------------------------------------------------------------
   192
   193 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   194 				; as Pointer
   195 2116 B5 98			lda :STACKORIGIN,x
   196 2118 85 88			sta A
   197 211A B5 A8			lda :STACKORIGIN+STACKWIDTH,x
   198 211C 85 89			sta A+1
   199 211E CA				dex
   200
   201 				; ---------------------  ASM Block 029  ---------------------
   202
   203 211F 20 87 20			jsr @fill
   204
   205
   206 				; ------------------------------------------------------------
   207
   208 = 0088			A	= edx
   209 = 008C			COUNT	= ecx
   210 = 0084			VALUE	= eax
   211 2122			@exit
   212 					.ifdef @new
   213 					lda <@VarData
   214 					sta :ztmp
   215 					lda >@VarData
   216 					ldy #@VarDataSize-1
   217 					jmp @FreeMem
   218 					els
   219 2122 60				rts						; ret
   220 					eif
   221 				.endl
   222
   223 2123			.local	MOVE_004C					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER
   224
   225 				; ------------------------------------------------------------
   226
   227 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   228 				; as Pointer
   229 2123 B5 98			lda :STACKORIGIN,x
   230 2125 85 84			sta COUNT
   231 2127 B5 A8			lda :STACKORIGIN+STACKWIDTH,x
   232 2129 85 85			sta COUNT+1
   233 212B CA				dex
   234
   235 				; ------------------------------------------------------------
   236
   237 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   238 				; as Pointer
   239 212C B5 98			lda :STACKORIGIN,x
   240 212E 85 8C			sta DEST
   241 2130 B5 A8			lda :STACKORIGIN+STACKWIDTH,x
   242 2132 85 8D			sta DEST+1
   243 2134 CA				dex
   244
   245 				; ------------------------------------------------------------
   246
   247 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   248 				; as Pointer
   249 2135 B5 98			lda :STACKORIGIN,x
   250 2137 85 88			sta SOURCE
   251 2139 B5 A8			lda :STACKORIGIN+STACKWIDTH,x
   252 213B 85 89			sta SOURCE+1
   253 213D CA				dex
   254
   255 				; ---------------------  ASM Block 031  ---------------------
   256
   257 213E 20 32 20			jsr @move
   258
   259
   260 				; ------------------------------------------------------------
   261
   262 = 0088			SOURCE	= edx
   263 = 008C			DEST	= ecx
   264 = 0084			COUNT	= eax
   265 2141			@exit
   266 					.ifdef @new
   267 					lda <@VarData
   268 					sta :ztmp
   269 					lda >@VarData
   270 					ldy #@VarDataSize-1
   271 					jmp @FreeMem
   272 					els
   273 2141 60				rts						; ret
   274 					eif
   275 				.endl
   276
   277 2142			.local	PAUSE_006A					; PROCEDURE | ASSEMBLER | OVERLOAD
   278
   279 				; ---------------------  ASM Block 039  ---------------------
   280
   281 2142 A5 14 C5 14 F0 FC		lda:cmp:req :rtclok+2
   282
   283 2148			@exit
   284 					.ifdef @new
   285 					lda <@VarData
   286 					sta :ztmp
   287 					lda >@VarData
   288 					ldy #@VarDataSize-1
   289 					jmp @FreeMem
   290 					els
   291 2148 60				rts						; ret
   292 					eif
   293 				.endl
   294
   295 				; ------------------------------------------------------------
   296
   297 = 0101			__PORTB_BANKS	= $0101
   298 = 0648			M_PI_2	= $0648
   299 = 0192			D_PI_2	= $0192
   300 = 0004			D_PI_180	= $04
   301 = 0000			MGTIA	= $00
   302 = 0080			MVBXE	= $80
   303 = 0000			VBXE_XDLADR	= $00
   304 = 0100			VBXE_BCBADR	= $0100
   305 = 1000			VBXE_MAPADR	= $1000
   306 = 5000			VBXE_OVRADR	= $5000
   307 = B000			VBXE_WINDOW	= $B000
   308 = 0000			IDLI	= $00
   309 = 0001			IVBL	= $01
   310 = 00FE			CH_DELCHR	= $FE
   311 = 009B			CH_ENTER	= $9B
   312 = 001B			CH_ESC	= $1B
   313 = 001C			CH_CURS_UP	= $1C
   314 = 001D			CH_CURS_DOWN	= $1D
   315 = 001E			CH_CURS_LEFT	= $1E
   316 = 001F			CH_CURS_RIGHT	= $1F
   317 = 007F			CH_TAB	= $7F
   318 = 009B			CH_EOL	= $9B
   319 = 007D			CH_CLR	= $7D
   320 = 00FD			CH_BELL	= $FD
   321 = 007E			CH_DEL	= $7E
   322 = 009C			CH_DELLINE	= $9C
   323 = 009D			CH_INSLINE	= $9D
   324 = 0000			COLOR_BLACK	= $00
   325 = 000E			COLOR_WHITE	= $0E
   326 = 0032			COLOR_RED	= $32
   327 = 0096			COLOR_CYAN	= $96
   328 = 0068			COLOR_VIOLET	= $68
   329 = 00C4			COLOR_GREEN	= $C4
   330 = 0074			COLOR_BLUE	= $74
   331 = 00EE			COLOR_YELLOW	= $EE
   332 = 0028			COLOR_ORANGE	= $28
   333 = 00E4			COLOR_BROWN	= $E4
   334 = 003C			COLOR_LIGHTRED	= $3C
   335 = 0004			COLOR_GRAY1	= $04
   336 = 0006			COLOR_GRAY2	= $06
   337 = 000A			COLOR_GRAY3	= $0A
   338 = 00CC			COLOR_LIGHTGREEN	= $CC
   339 = 007C			COLOR_LIGHTBLUE	= $7C
   340 = 0004			FMOPENREAD	= $04
   341 = 0008			FMOPENWRITE	= $08
   342 = 0009			FMOPENAPPEND	= $09
   343 = 000C			FMOPENREADWRITE	= $0C
   344 = 2404			SCREENWIDTH	= DATAORIGIN+$0000
   345 = 2406			SCREENHEIGHT	= DATAORIGIN+$0002
   346 = 2408			DATESEPARATOR	= DATAORIGIN+$0004
   347 = D014			TVSYSTEM	= $D014
   348 = D20A			RND	= $D20A
   349 = 02C0			adr.PALETTE	= $02C0
   350 2149			.var PALETTE	= adr.PALETTE .word
   351 = D012			adr.HPALETTE	= $D012
   352 2149			.var HPALETTE	= adr.HPALETTE .word
   353 = 2409			FILEMODE	= DATAORIGIN+$0005
   354 = 240A			GRAPHMODE	= DATAORIGIN+$0006
   355 = 240B			IORESULT	= DATAORIGIN+$0007
   356 = 240C			EOLN	= DATAORIGIN+$0008
   357 = 240D			RNDSEED	= DATAORIGIN+$0009
   358
   359 = 2149 C0 02		PALETTE
   359 = 214B 12 D0		HPALETTE
   359 				.endl							; UNIT SYSTEM
   360
   361 				; ------------------------------------------------------------
   362
   363 214D			.local	REGISTERS					; UNIT
   364
   365 				; ------------------------------------------------------------
   366
   367 = 0014			RTCLOK	= $14
   368 = D000			HPOSP0	= $D000
   369 = D001			HPOSP1	= $D001
   370 = D004			HPOSM0	= $D004
   371 = D005			HPOSM1	= $D005
   372 = D006			HPOSM2	= $D006
   373 = D007			HPOSM3	= $D007
   374 = D008			SIZEP0	= $D008
   375 = D009			SIZEP1	= $D009
   376 = D00A			SIZEP2	= $D00A
   377 = D00B			SIZEP3	= $D00B
   378 = D00C			SIZEM	= $D00C
   379 = D011			GRAFM	= $D011
   380 = D012			COLPM0	= $D012
   381 = D013			COLPM1	= $D013
   382 = D014			COLPM2	= $D014
   383 = D015			COLPM3	= $D015
   384 = D017			COLPF1	= $D017
   385 = D018			COLPF2	= $D018
   386 = D01A			COLBK	= $D01A
   387 = D01B			PRIOR	= $D01B
   388 = D01D			GRACTL	= $D01D
   389 = D20A			RND	= $D20A
   390 = D300			PORTA	= $D300
   391 = D301			PORTB	= $D301
   392 = D302			PACTL	= $D302
   393 = D400			DMACTL	= $D400
   394 = D402			DLIST	= $D402
   395 = D407			PMBASE	= $D407
   396 = D40A			WSYNC	= $D40A
   397 = D40B			VCOUNT	= $D40B
   398 = D40E			NMIEN	= $D40E
   399 = FFFA			NMIVEC	= $FFFA
   400 = D000			HPOSP01	= $D000
   401 = D008			SIZEP01	= $D008
   402 = D012			COLPM01	= $D012
   403
   404 				.endl							; UNIT REGISTERS
   405
   406 				; ------------------------------------------------------------
   407
   408 214D			.local	SYS						; UNIT
   409
   410 214D			.local	NMI						; PROCEDURE | ASSEMBLER | INTERRUPT
   411
   412 				; ---------------------  ASM Block 049  ---------------------
   413
   414
   415 				      bit NMIST \ bpl vbi     ; check kind of interrupt
   415 214D 2C 0F D4		      BIT NMIST 
   415 2150 10 03		 BPL VBI     
   416 = 2152			.def  :__dlijmp
   417 2152 4C 5A 21		      jmp __off               ; VDSLST
   418 2155 E6 14		vbi:  inc RTCLOK+2
   419 = 2157			.def  :__vbijmp
   420 2157 4C 5A 21		      jmp __off               ; VBIVEC
   421 = 215A			.def  :__off
   422
   423 215A 40				rti						; ret
   424 				.endl
   425
   426 215B			.local	SETVBI						; PROCEDURE | ASSEMBLER
   427
   428 				; ------------------------------------------------------------
   429
   430 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   431 				; as Pointer
   432 215B B5 98			lda :STACKORIGIN,x
   433 215D 8D 0F 24			sta A
   434 2160 B5 A8			lda :STACKORIGIN+STACKWIDTH,x
   435 2162 8D 10 24			sta A+1
   436 2165 CA				dex
   437
   438 				; ---------------------  ASM Block 050  ---------------------
   439
   440
   441 2166 AD 0F 24 8D 58 21 +   mwa a __vbijmp+1
   442
   443
   444 				; ------------------------------------------------------------
   445
   446 = 240F			A	= DATAORIGIN+$000B
   447
   448 = 240F			@VarData	= A
   449 = 0002			@VarDataSize	= 2
   450
   451 2172			@exit
   452 					.ifdef @new
   453 					lda <@VarData
   454 					sta :ztmp
   455 					lda >@VarData
   456 					ldy #@VarDataSize-1
   457 					jmp @FreeMem
   458 					els
   459 2172 60				rts						; ret
   460 					eif
   461 				.endl
   462
   463 2173			.local	SETDLI						; PROCEDURE | ASSEMBLER
   464
   465 				; ------------------------------------------------------------
   466
   467 				; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
   468 				; as Pointer
   469 2173 B5 98			lda :STACKORIGIN,x
   470 2175 8D 11 24			sta A
   471 2178 B5 A8			lda :STACKORIGIN+STACKWIDTH,x
   472 217A 8D 12 24			sta A+1
   473 217D CA				dex
   474
   475 				; ---------------------  ASM Block 051  ---------------------
   476
   477
   478 217E AD 11 24 8D 53 21 +   mwa a __dlijmp+1
   479
   480
   481 				; ------------------------------------------------------------
   482
   483 = 2411			A	= DATAORIGIN+$000D
   484
   485 = 2411			@VarData	= A
   486 = 0002			@VarDataSize	= 2
   487
   488 218A			@exit
   489 					.ifdef @new
   490 					lda <@VarData
   491 					sta :ztmp
   492 					lda >@VarData
   493 					ldy #@VarDataSize-1
   494 					jmp @FreeMem
   495 					els
   496 218A 60				rts						; ret
   497 					eif
   498 				.endl
   499
   500 218B			.local	SYSTEMOFF					; PROCEDURE
   501
   502 				; ---------------------  ASM Block 054  ---------------------
   503
   504 218B 78			 sei 
   505
   506 				; optimize OK (SYS), line = 63
   507
   508 218C A9 00			lda #$00
   509 218E 8D 0E D4			sta REGISTERS.NMIEN
   510 2191 A9 FE			lda #$FE
   511 2193 8D 01 D3			sta REGISTERS.PORTB
   512 2196 A9 4D			lda <NMI
   513 2198 8D FA FF			sta REGISTERS.NMIVEC
   514 219B A9 21			lda >NMI
   515 219D 8D FB FF			sta REGISTERS.NMIVEC+1
   516 21A0 A9 C0			lda #$C0
   517 21A2 8D 0E D4			sta REGISTERS.NMIEN
   518 21A5			@exit
   519 					.ifdef @new
   520 					lda <@VarData
   521 					sta :ztmp
   522 					lda >@VarData
   523 					ldy #@VarDataSize-1
   524 					jmp @FreeMem
   525 					els
   526 21A5 60				rts						; ret
   527 					eif
   528 				.endl
   529
   530 				; ------------------------------------------------------------
   531 				; ------------------------------------------------------------
   532 21A6			@UnitInit
   533
   534 21A6 60				rts
   535
   536 				; ------------------------------------------------------------
   537
   538 				.endl							; UNIT SYS
   539
   540 				; ------------------------------------------------------------
   541
   542 21A7			.local	GR						; UNIT
   543
   544 21A7			.local	MODE2						; PROCEDURE
   545
   546 				; optimize OK (GR), line = 20
   547
   548 21A7 A9 00			lda #$00
   549 21A9 8D 02 D4			sta REGISTERS.DLIST
   550 21AC A9 11			lda #$11
   551 21AE 8D 03 D4			sta REGISTERS.DLIST+1
   552 21B1			@exit
   553 					.ifdef @new
   554 					lda <@VarData
   555 					sta :ztmp
   556 					lda >@VarData
   557 					ldy #@VarDataSize-1
   558 					jmp @FreeMem
   559 					els
   560 21B1 60				rts						; ret
   561 					eif
   562 				.endl
   563
   564 				; ------------------------------------------------------------
   565 				; ------------------------------------------------------------
   566 21B2			@UnitInit
   567
   568 21B2 60				rts
   569
   570 				; ------------------------------------------------------------
   571
   572 = 1000			PM_ADR	= $1000
   573 = 1300			M0_ADR	= $1300
   574 = 1400			P0_ADR	= $1400
   575 = 1500			P1_ADR	= $1500
   576 = 1000			GFX_SHIP_ADR	= $1000
   577 = 000A			GFX_SHIP_SEG	= $0A
   578 = 0E0E			SHIP_COL	= $0E0E
   579 = 0030			SHIP_LEFT_LIMIT	= $30
   580 = 00C0			SHIP_RIGHT_LIMIT	= $C0
   581 = 0020			SHIP_TOP_LIMIT	= $20
   582 = 00A0			SHIP_BOTTOM_LIMIT	= $A0
   583 = 0008			JOY_LEFT	= $08
   584 = 0004			JOY_RIGHT	= $04
   585 = 0002			JOY_UP	= $02
   586 = 0001			JOY_DOWN	= $01
   587 = 1100			DL_2	= $1100
   588 = E000			GAME_LMS	= $E000
   589
   590 				.endl							; UNIT GR
   591
   592 				; ------------------------------------------------------------
   593
   594 21B3			.local	SPRITES						; UNIT
   595
   596 21B3			.local	COPYSHIP					; PROCEDURE
   597
   598 				; optimize OK (SPRITES), line = 31
   599
   600 21B3 A5 02			lda BSHIPY
   601 21B5 85 8C			sta :ecx
   602 21B7 A9 14			lda #$14
   603 21B9 85 8D			sta :ecx+1
   604 21BB A9 00			lda #$00
   605 21BD 85 88			sta :edx
   606 21BF A9 10			lda #$10
   607 21C1 85 89			sta :edx+1
   608 21C3 A9 0A			lda #$0A
   609 21C5 85 84			sta :eax
   610 21C7 A9 00			lda #$00
   611 21C9 85 85			sta :eax+1
   612 21CB 20 32 20			jsr @move
   613
   614 				; optimize OK (SPRITES), line = 32
   615
   616 21CE A5 02			lda BSHIPY
   617 21D0 85 8C			sta :ecx
   618 21D2 A9 15			lda #$15
   619 21D4 85 8D			sta :ecx+1
   620 21D6 A9 0A			lda #$0A
   621 21D8 85 88			sta :edx
   622 21DA A9 10			lda #$10
   623 21DC 85 89			sta :edx+1
   624 21DE A9 0A			lda #$0A
   625 21E0 85 84			sta :eax
   626 21E2 A9 00			lda #$00
   627 21E4 85 85			sta :eax+1
   628 21E6 20 32 20			jsr @move
   629 21E9			@exit
   630 					.ifdef @new
   631 					lda <@VarData
   632 					sta :ztmp
   633 					lda >@VarData
   634 					ldy #@VarDataSize-1
   635 					jmp @FreeMem
   636 					els
   637 21E9 60				rts						; ret
   638 					eif
   639 				.endl
   640
   641 21EA			.local	INIT						; PROCEDURE
   642
   643 				; optimize OK (SPRITES), line = 37
   644
   645 21EA				.LOCAL
   646 21EA A0 00			ldy #$00
   647 21EC 98				tya
   648 21ED 99 00 13 99 80 13 + fill	:10 sta $1300+#*$80,y
   649 220B C8				iny
   650 220C 10 DF			bpl fill
   651 					.ENDL
   652
   653 				; optimize OK (SPRITES), line = 38
   654
   655 220E A0 70			ldy #256-$90
   656 2210 A9 FF			lda #$FF
   657 2212 99 B0 12 C8 D0 FA		sta:rne $1320+$90-256,y+
   658
   659 				; optimize OK (SPRITES), line = 40
   660
   661 2218 A9 10			lda #$10
   662 221A 8D 07 D4			sta REGISTERS.PMBASE
   663
   664 				; optimize OK (SPRITES), line = 41
   665
   666 221D A9 0A			lda #$0A
   667 221F 8D 15 D0			sta REGISTERS.COLPM3
   668 2222 A9 0E			lda #$0E
   669 2224 8D 12 D0			sta REGISTERS.COLPM01
   670 2227 8D 13 D0			sta REGISTERS.COLPM01+1
   671
   672 				; optimize OK (SPRITES), line = 42
   673
   674 222A A9 50			lda #$50
   675 222C 85 02			sta BSHIPY
   676 222E A9 30			lda #$30
   677 2230 85 00			sta BHPOSP0
   678 2232 A9 38			lda #$38
   679 2234 85 01			sta BHPOSP1
   680 2236 A5 00			lda WSHIPX
   681 2238 8D 00 D0			sta REGISTERS.HPOSP01
   682 223B A5 01			lda WSHIPX+1
   683 223D 8D 01 D0			sta REGISTERS.HPOSP01+1
   684
   685 				; optimize OK (SPRITES), line = 43
   686
   687 2240 A9 00			lda #$00
   688 2242 8D 08 D0			sta REGISTERS.SIZEP01
   689 2245 8D 09 D0			sta REGISTERS.SIZEP01+1
   690 2248 8D 0C D0			sta REGISTERS.SIZEM
   691 224B 8D 1B D0			sta REGISTERS.PRIOR
   692 224E A9 03			lda #$03
   693 2250 8D 1D D0			sta REGISTERS.GRACTL
   694
   695 				; optimize FAIL ('COPYSHIP', SPRITES), line = 45
   696
   697 2253 20 B3 21			jsr COPYSHIP
   698 2256			@exit
   699 					.ifdef @new
   700 					lda <@VarData
   701 					sta :ztmp
   702 					lda >@VarData
   703 					ldy #@VarDataSize-1
   704 					jmp @FreeMem
   705 					els
   706 2256 60				rts						; ret
   707 					eif
   708 				.endl
   709
   710 2257			.local	MOVESHIP					; PROCEDURE
   711
   712 				; optimize OK (SPRITES), line = 51
   713
   714 2257 A9 0C			lda #$0C
   715 2259 85 FF			sta BMASK
   716
   717 				; optimize OK (SPRITES), line = 52
   718
   719 225B A9 01			lda #$01
   720 225D 85 FE			sta B01I
   721
   722 225F			l_00F1
   723 				; --- ForToDoCondition
   724
   725 				; ------------------------------------------------------------
   726
   727 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   728 				; as Pointer
   729
   730 225F E8				inx
   731 2260 A5 03 95 98			mva JOYDIRECTION :STACKORIGIN,x
   732
   733 				; ------------------------------------------------------------
   734
   735 				; Push BYTE / CHAR / SHORTINT / BOOLEAN
   736 				; as Pointer
   737
   738 2264 E8				inx
   739 2265 A5 FF 95 98			mva BMASK :STACKORIGIN,x
   740
   741 				; Generate Binary Operation for BYTE
   742 2269 20 00 20			jsr andAL_CL					; and al, cl
   743 226C CA				dex
   744
   745 				; GenerateCaseProlog
   746 226D CA				dex
   747
   748 				; GenerateCaseEqualityCheck
   749 226E B5 99			lda :STACKORIGIN+1,x
   750 2270 C9 04			cmp #$04
   751 2272 D0 20			jne l_0111
   752 2274			@
   753
   754 				; optimize OK (SPRITES), line = 55
   755
   756 2274 A5 01			lda BHPOSP1
   757 2276 C9 C0			cmp #$C0
   758 2278 B0 17			jcs l_0123
   759
   760 				; optimize OK (SPRITES), line = 56
   761
   762 227A A5 00			lda WSHIPX
   763 227C 18 69 01			add #$01
   764 227F 85 00			sta WSHIPX
   765 2281 A5 01			lda WSHIPX+1
   766 2283 69 01			adc #$01
   767 2285 85 01			sta WSHIPX+1
   768 2287 A5 00			lda WSHIPX
   769 2289 8D 00 D0			sta REGISTERS.HPOSP01
   770 228C A5 01			lda WSHIPX+1
   771 228E 8D 01 D0			sta REGISTERS.HPOSP01+1
   772 2291			l_0123
   773
   774 				; GenerateCaseStatementEpilog
   775 2291 4C E2 22			jmp a_0002
   776 2294			l_0111
   777
   778 				; GenerateCaseEqualityCheck
   779 2294 B5 99			lda :STACKORIGIN+1,x
   780 2296 C9 08			cmp #$08
   781 2298 D0 20			jne l_0135
   782 229A			@
   783
   784 				; optimize OK (SPRITES), line = 60
   785
   786 229A A5 00			lda BHPOSP0
   787 229C C9 31			cmp #$31
   788 229E 90 17			jcc l_0147
   789
   790 				; optimize OK (SPRITES), line = 61
   791
   792 22A0 A5 00			lda WSHIPX
   793 22A2 38 E9 01			sub #$01
   794 22A5 85 00			sta WSHIPX
   795 22A7 A5 01			lda WSHIPX+1
   796 22A9 E9 01			sbc #$01
   797 22AB 85 01			sta WSHIPX+1
   798 22AD A5 00			lda WSHIPX
   799 22AF 8D 00 D0			sta REGISTERS.HPOSP01
   800 22B2 A5 01			lda WSHIPX+1
   801 22B4 8D 01 D0			sta REGISTERS.HPOSP01+1
   802 22B7			l_0147
   803
   804 				; GenerateCaseStatementEpilog
   805 22B7 4C E2 22			jmp a_0002
   806 22BA			l_0135
   807
   808 				; GenerateCaseEqualityCheck
   809 22BA B5 99			lda :STACKORIGIN+1,x
   810 22BC C9 02			cmp #$02
   811 22BE D0 0E			jne l_0159
   812 22C0			@
   813
   814 				; optimize OK (SPRITES), line = 65
   815
   816 22C0 A5 02			lda BSHIPY
   817 22C2 C9 21			cmp #$21
   818 22C4 90 05			jcc l_016B
   819
   820 				; optimize FAIL (0, SPRITES), line = 66
   821
   822 22C6 C6 02			dec BSHIPY
   823 22C8 20 B3 21			jsr COPYSHIP
   824 22CB			l_016B
   825
   826 				; GenerateCaseStatementEpilog
   827 22CB 4C E2 22			jmp a_0002
   828 22CE			l_0159
   829
   830 				; GenerateCaseEqualityCheck
   831 22CE B5 99			lda :STACKORIGIN+1,x
   832 22D0 C9 01			cmp #$01
   833 22D2 D0 0E			jne l_017C
   834 22D4			@
   835
   836 				; optimize OK (SPRITES), line = 70
   837
   838 22D4 A5 02			lda BSHIPY
   839 22D6 C9 A0			cmp #$A0
   840 22D8 B0 05			jcs l_018E
   841
   842 				; optimize FAIL (0, SPRITES), line = 71
   843
   844 22DA E6 02			inc BSHIPY
   845 22DC 20 B3 21			jsr COPYSHIP
   846 22DF			l_018E
   847
   848 				; GenerateCaseStatementEpilog
   849 22DF 4C E2 22			jmp a_0002
   850 22E2			l_017C
   851
   852 				; GenerateCaseEpilog
   853 22E2			a_0002
   854
   855 				; optimize OK (SPRITES), line = 75
   856
   857 22E2 A9 03			lda #$03
   858 22E4 85 FF			sta BMASK
   859
   860 				; --- ForToDoEpilog
   861 22E6 C6 FE			dec B01I
   862 22E8 30 03 4C 5F 22		jpl l_00F1
   863 22ED			l_00FF
   864
   865 				; ------------------------------------------------------------
   866
   867 = 00FF			BMASK	= $FF
   868 = 0000			@FORTMP_00EE	= $00
   869 22ED			@exit
   870 					.ifdef @new
   871 					lda <@VarData
   872 					sta :ztmp
   873 					lda >@VarData
   874 					ldy #@VarDataSize-1
   875 					jmp @FreeMem
   876 					els
   877 22ED 60				rts						; ret
   878 					eif
   879 				.endl
   880
   881 				; ------------------------------------------------------------
   882 				; ------------------------------------------------------------
   883 22EE			@UnitInit
   884
   885 22EE 60				rts
   886
   887 				; ------------------------------------------------------------
   888
   889 = 0003			JOYDIRECTION	= $03
   890 = 1000			PM_ADR	= $1000
   891 = 1300			M0_ADR	= $1300
   892 = 1400			P0_ADR	= $1400
   893 = 1500			P1_ADR	= $1500
   894 = 1000			GFX_SHIP_ADR	= $1000
   895 = 000A			GFX_SHIP_SEG	= $0A
   896 = 0E0E			SHIP_COL	= $0E0E
   897 = 0030			SHIP_LEFT_LIMIT	= $30
   898 = 00C0			SHIP_RIGHT_LIMIT	= $C0
   899 = 0020			SHIP_TOP_LIMIT	= $20
   900 = 00A0			SHIP_BOTTOM_LIMIT	= $A0
   901 = 0008			JOY_LEFT	= $08
   902 = 0004			JOY_RIGHT	= $04
   903 = 0002			JOY_UP	= $02
   904 = 0001			JOY_DOWN	= $01
   905 = 1100			DL_2	= $1100
   906 = E000			GAME_LMS	= $E000
   907 = 0000			BHPOSP0	= $00
   908 = 0001			BHPOSP1	= $01
   909 = 0002			BSHIPY	= $02
   910 = 00FE			B01I	= $FE
   911 = 0000			WSHIPX	= $00
   912
   913 				.endl							; UNIT SPRITES
   914
   915 22EF			.local	VBI						; PROCEDURE | INTERRUPT
   916
   917 				; ---------------------  ASM Block 055  ---------------------
   918
   919 22EF 48 8A 48 98 48	 phr 
   920
   921 				; ---------------------  ASM Block 056  ---------------------
   922
   923 22F4 68 A8 68 AA 68	 plr 
   924 22F9 40				rti						; ret
   925 				.endl
   926
   927 22FA			.local	JOY						; PROCEDURE | INTERRUPT
   928
   929 				; ---------------------  ASM Block 057  ---------------------
   930
   931 22FA 48 8A 48 98 48	 phr 
   932
   933 				; optimize OK (main.pas), line = 30
   934
   935 22FF AD 00 D3			lda REGISTERS.PORTA
   936 2302 85 03			sta SPRITES.JOYDIRECTION
   937
   938 				; optimize OK (main.pas), line = 31
   939
   940 2304 29 0F			and #$0F
   941 2306 C9 0F			cmp #$0F
   942 2308 F0 03			jeq l_01CB
   943 230A 20 57 22			jsr SPRITES.MOVESHIP
   944 230D			l_01CB
   945
   946 				; optimize FAIL ('SYS.SETDLI', main.pas), line = 33
   947
   948 230D E8				inx
   949 230E AD 15 24 95 98		mva PSTARS :STACKORIGIN,x
   950 2313 AD 16 24 95 A8		mva PSTARS+1 :STACKORIGIN+STACKWIDTH,x
   951 2318 20 73 21			jsr SYS.SETDLI
   952
   953 				; ---------------------  ASM Block 058  ---------------------
   954
   955 231B 68 A8 68 AA 68	 plr 
   956 2320 40				rti						; ret
   957 				.endl
   958
   959 2321			.local	STARS						; PROCEDURE | INTERRUPT
   960
   961 				; ---------------------  ASM Block 059  ---------------------
   962
   963 2321 48 8A 48 98 48	 phr 
   964
   965 				; optimize OK (main.pas), line = 42
   966
   967 2326 A9 7C			lda #$7C
   968 2328 85 FE			sta B01I
   969
   970 232A			l_01DF
   971 				; --- ForToDoCondition
   972
   973 				; ---------------------  ASM Block 060  ---------------------
   974
   975 232A 8D 0A D4		 sta WSYNC 
   976
   977 				; optimize OK (main.pas), line = 44
   978
   979 232D A4 FE			ldy B01I
   980 232F B9 00 12			lda adr.ASTARS,y
   981 2332 8D 07 D0			sta REGISTERS.HPOSM3
   982
   983 				; optimize OK (main.pas), line = 45
   984
   985 2335 B9 00 12			lda adr.ASTARS,y
   986 2338 38 F9 7D 12			sub adr.ASPEED,y
   987 233C 99 00 12			sta adr.ASTARS,y
   988
   989 				; optimize OK (main.pas), line = 46
   990
   991 233F AD 0A D2			lda SYSTEM.RND
   992 2342 8D 15 D0			sta REGISTERS.COLPM3
   993
   994 				; --- ForToDoEpilog
   995 2345 C6 FE			dec B01I
   996 2347 10 E1			jpl l_01DF
   997 2349			l_01ED
   998
   999 				; optimize FAIL ('SYS.SETDLI', main.pas), line = 49
  1000
  1001 2349 E8				inx
  1002 234A AD 13 24 95 98		mva PJOY :STACKORIGIN,x
  1003 234F AD 14 24 95 A8		mva PJOY+1 :STACKORIGIN+STACKWIDTH,x
  1004 2354 20 73 21			jsr SYS.SETDLI
  1005
  1006 				; ---------------------  ASM Block 061  ---------------------
  1007
  1008 2357 68 A8 68 AA 68	 plr 
  1009
  1010 				; ------------------------------------------------------------
  1011
  1012 = 0000			@FORTMP_01DC	= $00
  1013 235C 40				rti						; ret
  1014 				.endl
  1015
  1016 235D			.local	INIT						; PROCEDURE
  1017
  1018 				; optimize FAIL ('SYSTEM.PAUSE_006A', main.pas), line = 56
  1019
  1020 235D 20 42 21			jsr SYSTEM.PAUSE_006A
  1021 2360 A9 00			lda #$00
  1022 2362 8D 00 D4			sta REGISTERS.DMACTL
  1023 2365 20 8B 21			jsr SYS.SYSTEMOFF
  1024
  1025 				; optimize OK (main.pas), line = 58
  1026
  1027 2368 A9 00			lda #$00
  1028 236A 85 88			sta :edx
  1029 236C A9 E0			lda #$E0
  1030 236E 85 89			sta :edx+1
  1031 2370 A9 C0			lda #$C0
  1032 2372 85 8C			sta :ecx
  1033 2374 A9 03			lda #$03
  1034 2376 85 8D			sta :ecx+1
  1035 2378 A9 00			lda #$00
  1036 237A 85 84			sta :eax
  1037 237C 20 87 20			jsr @fill
  1038
  1039 				; optimize OK (main.pas), line = 60
  1040
  1041 237F A9 7C			lda #$7C
  1042 2381 85 FE			sta B01I
  1043
  1044 2383			l_0224
  1045 				; --- ForToDoCondition
  1046
  1047 				; optimize OK (main.pas), line = 61
  1048
  1049 2383 A4 FE			ldy B01I
  1050 2385 AD 0A D2			lda SYSTEM.RND
  1051 2388 99 00 12			sta adr.ASTARS,y
  1052
  1053 				; optimize OK (main.pas), line = 62
  1054
  1055 238B 29 03			and #$03
  1056 238D 18 69 01			add #$01
  1057 2390 99 7D 12			sta adr.ASPEED,y
  1058
  1059 				; --- ForToDoEpilog
  1060 2393 C6 FE			dec B01I
  1061 2395 10 EC			jpl l_0224
  1062 2397			l_0232
  1063
  1064 				; optimize FAIL ('SPRITES.INIT', main.pas), line = 65
  1065
  1066 2397 20 EA 21			jsr SPRITES.INIT
  1067
  1068 				; optimize FAIL ('GR.MODE2', main.pas), line = 66
  1069
  1070 239A 20 A7 21			jsr GR.MODE2
  1071 239D A9 00			lda #$00
  1072 239F 8D 1A D0			sta REGISTERS.COLBK
  1073 23A2 A9 02			lda #$02
  1074 23A4 8D 18 D0			sta REGISTERS.COLPF2
  1075
  1076 				; optimize OK (main.pas), line = 67
  1077
  1078 23A7 AD 02 D3			lda REGISTERS.PACTL
  1079 23AA 09 04			ora #$04
  1080 23AC 8D 02 D3			sta REGISTERS.PACTL
  1081
  1082 				; optimize OK (main.pas), line = 68
  1083
  1084 23AF A9 FA			lda <JOY
  1085 23B1 8D 13 24			sta PJOY
  1086 23B4 A9 22			lda >JOY
  1087 23B6 8D 14 24			sta PJOY+1
  1088 23B9 A9 21			lda <STARS
  1089 23BB 8D 15 24			sta PSTARS
  1090 23BE A9 23			lda >STARS
  1091 23C0 8D 16 24			sta PSTARS+1
  1092
  1093 				; optimize FAIL ('SYS.SETVBI', main.pas), line = 70
  1094
  1095 23C3 E8				inx
  1096 23C4 A9 EF 95 98			mva <VBI :STACKORIGIN,x
  1097 23C8 A9 22 95 A8			mva >VBI :STACKORIGIN+STACKWIDTH,x
  1098 23CC 20 5B 21			jsr SYS.SETVBI
  1099
  1100 				; optimize FAIL ('SYS.SETDLI', main.pas), line = 71
  1101
  1102 23CF E8				inx
  1103 23D0 A9 FA 95 98			mva <JOY :STACKORIGIN,x
  1104 23D4 A9 22 95 A8			mva >JOY :STACKORIGIN+STACKWIDTH,x
  1105 23D8 20 73 21			jsr SYS.SETDLI
  1106
  1107 				; optimize FAIL ('SYSTEM.PAUSE_006A', main.pas), line = 73
  1108
  1109 23DB 20 42 21			jsr SYSTEM.PAUSE_006A
  1110 23DE A9 3E			lda #$3E
  1111 23E0 8D 00 D4			sta REGISTERS.DMACTL
  1112
  1113 				; ------------------------------------------------------------
  1114
  1115 = 0000			@FORTMP_0221	= $00
  1116 23E3			@exit
  1117 					.ifdef @new
  1118 					lda <@VarData
  1119 					sta :ztmp
  1120 					lda >@VarData
  1121 					ldy #@VarDataSize-1
  1122 					jmp @FreeMem
  1123 					els
  1124 23E3 60				rts						; ret
  1125 					eif
  1126 				.endl
  1127 23E4			l_0007
  1128
  1129 				; optimize FAIL ('INIT', main.pas), line = 77
  1130
  1131 23E4 20 5D 23			jsr INIT
  1132
  1133 				; --- RepeatUntilProlog
  1134 23E7			l_0275
  1135
  1136 				; optimize OK (main.pas), line = 78
  1137
  1138 23E7 4C E7 23			jmp l_0275
  1139
  1140 				; ------------------------------------------------------------
  1141
  1142 = 1000			PM_ADR	= $1000
  1143 = 1300			M0_ADR	= $1300
  1144 = 1400			P0_ADR	= $1400
  1145 = 1500			P1_ADR	= $1500
  1146 = 1000			GFX_SHIP_ADR	= $1000
  1147 = 000A			GFX_SHIP_SEG	= $0A
  1148 = 0E0E			SHIP_COL	= $0E0E
  1149 = 0030			SHIP_LEFT_LIMIT	= $30
  1150 = 00C0			SHIP_RIGHT_LIMIT	= $C0
  1151 = 0020			SHIP_TOP_LIMIT	= $20
  1152 = 00A0			SHIP_BOTTOM_LIMIT	= $A0
  1153 = 0008			JOY_LEFT	= $08
  1154 = 0004			JOY_RIGHT	= $04
  1155 = 0002			JOY_UP	= $02
  1156 = 0001			JOY_DOWN	= $01
  1157 = 1100			DL_2	= $1100
  1158 = E000			GAME_LMS	= $E000
  1159 = 00FE			B01I	= $FE
  1160 = 1200			adr.ASTARS	= $1200
  1161 23EA			.var ASTARS	= adr.ASTARS .word
  1162 = 127D			adr.ASPEED	= $127D
  1163 23EA			.var ASPEED	= adr.ASPEED .word
  1164 = 2413			PJOY	= DATAORIGIN+$000F
  1165 = 2415			PSTARS	= DATAORIGIN+$0011
  1166 23EA			@exit
  1167
  1168 23EA A2 00		@halt	ldx #$00
  1169 23EC 9A				txs
  1170 					.ifdef MAIN.@DEFINES.ROMOFF
  1171 					inc portb
  1172 					.endif
  1173
  1174 23ED A0 01			ldy #$01
  1175
  1176 23EF 60				rts
  1177
  1178 				; ------------------------------------------------------------
  1179
  1180 23F0 00 00 00 00 00 00 + IOCB@COPY	:16 brk
  1181
  1182 				; ------------------------------------------------------------
  1183
  1184 2400			.local	@DEFINES
  1185 2400			ATARI
  1186 				.endl
  1187
  1188 2400			.local	@RESOURCE
  1189 				.endl
  1190
  1191 = 2400 00 12		ASTARS
  1191 = 2402 7D 12		ASPEED
  1191 				.endl							; MAIN
  1192
  1193 				; ------------------------------------------------------------
  1194 				; ------------------------------------------------------------
  1195
  1196 				.macro	UNITINITIALIZATION
  1197 				
  1198 					.ifdef MAIN.SYSTEM.@UnitInit
  1199 					jsr MAIN.SYSTEM.@UnitInit
  1200 					eif
  1201 				
  1202 					.ifdef MAIN.REGISTERS.@UnitInit
  1203 					jsr MAIN.REGISTERS.@UnitInit
  1204 					eif
  1205 				
  1206 					.ifdef MAIN.SYS.@UnitInit
  1207 					jsr MAIN.SYS.@UnitInit
  1208 					eif
  1209 				
  1210 					.ifdef MAIN.GR.@UnitInit
  1211 					jsr MAIN.GR.@UnitInit
  1212 					eif
  1213 				
  1214 					.ifdef MAIN.SPRITES.@UnitInit
  1215 					jsr MAIN.SPRITES.@UnitInit
  1216 					eif
  1217 				.endm
  1218
  1219 				; ------------------------------------------------------------
  1220
  1221 					ift .SIZEOF(MAIN.SYSTEM) > 0
  1222 					.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
  1222 				SYSTEM: $2108..$214C
  1223 					eif
  1224
  1225 					ift .SIZEOF(MAIN.REGISTERS) > 0
  1226 					.print 'REGISTERS: ',MAIN.REGISTERS,'..',MAIN.REGISTERS+.SIZEOF(MAIN.REGISTERS)-1
  1227 					eif
  1228
  1229 					ift .SIZEOF(MAIN.SYS) > 0
  1230 					.print 'SYS: ',MAIN.SYS,'..',MAIN.SYS+.SIZEOF(MAIN.SYS)-1
  1230 				SYS: $214D..$21A6
  1231 					eif
  1232
  1233 					ift .SIZEOF(MAIN.GR) > 0
  1234 					.print 'GR: ',MAIN.GR,'..',MAIN.GR+.SIZEOF(MAIN.GR)-1
  1234 				GR: $21A7..$21B2
  1235 					eif
  1236
  1237 					ift .SIZEOF(MAIN.SPRITES) > 0
  1238 					.print 'SPRITES: ',MAIN.SPRITES,'..',MAIN.SPRITES+.SIZEOF(MAIN.SPRITES)-1
  1238 				SPRITES: $21B3..$22EE
  1239 					eif
  1240
  1241 					.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1
  1241 				CODE: $2000..$23FF
  1242
  1243 				; ------------------------------------------------------------
  1244
  1245 2404				.align $04
  1246
  1247 2404			DATAORIGIN
  1248 2404 28 00 18 00 2D 0C	.by  $28 $00 $18 $00 $2D $0C
  1249
  1250 = 0006			VARINITSIZE	= *-DATAORIGIN
  1251 = 0013			VARDATASIZE	= 19
  1252
  1253 = 2417			PROGRAMSTACK	= DATAORIGIN+VARDATASIZE
  1254
  1255 					.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK
  1255 				DATA: $2404..$2417
  1256
  1257 02E0-02E1> CF 20			run START
  1258
  1259 				; ------------------------------------------------------------
  1260
  1261 				.macro	STATICDATA
  1262 				.endm
  1263
  1264 					end
